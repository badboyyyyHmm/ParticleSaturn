<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子土星</title>
    
    <!-- Three.js 3D图形库 -->
    <script src="https://cdnjs.loli.net/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe手势识别库 -->
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="./libs//hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            color: white;
        }

        /* 3D场景容器 */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            /* 极度深邃的宇宙背景，微弱的径向光晕 */
            background: radial-gradient(circle at center, #050505 0%, #0b0b10 100%);
        }

        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 10;
            pointer-events: none;
        }

        .glass-panel {
            background: rgba(5, 5, 5, 0.7);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 2px;
            border-left: 2px solid #c5a059;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            max-width: 280px;
        }

        h1 {
            font-weight: 200;
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            color: #e0cda7;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .status-text {
            font-size: 0.85rem;
            color: #888;
            line-height: 1.6;
            font-family: monospace;
        }

        .highlight {
            color: #c5a059;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 40px;
            right: 40px;
            z-index: 10;
            pointer-events: auto;
        }

        /* 作者链接按钮 */
        #author-btn {
            position: absolute;
            top: 40px;
            right: 40px;
            z-index: 20;
            pointer-events: auto;
            text-decoration: none;
            color: #c5a059;
            border: 1px solid rgba(197, 160, 89, 0.4);
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 20px;
            font-size: 0.8rem;
            border-radius: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
            letter-spacing: 1px;
            font-family: monospace;
        }

        /* 作者链接按钮悬停效果 */
        #author-btn:hover {
            background: #c5a059;
            color: #000;
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.4);
        }

        button {
            background: transparent;
            border: 1px solid rgba(197, 160, 89, 0.3);
            color: #c5a059;
            padding: 12px 30px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* 按钮悬停效果 */
        button:hover {
            background: rgba(197, 160, 89, 0.1);
            border-color: #c5a059;
            box-shadow: 0 0 15px rgba(197, 160, 89, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-align: center;
            color: #444;
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        /* 手部关键点显示画布样式 */
        #hand-landmarks-canvas {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 6;
        }

        /* 隐藏用于MediaPipe手势识别的视频元素 */
        .input_video { display: none; }
    </style>
</head>
<body>

    <video class="input_video"></video>
    
    <!-- 作者链接按钮 -->
    <a id="author-btn" href="https://www.yjln.com" target="_blank">By Mr.lun</a>

    <!-- 手部关键点显示画布 -->
    <canvas id="hand-landmarks-canvas"></canvas>

    <div id="loading">
        正在构建粒子与行星数据...
    </div>

    <!-- UI信息面板 -->
    <div id="ui-layer">
        <div class="glass-panel">
            <h1>土星</h1>
            <div class="status-text">
                数据流状态: <span id="status-indicator" class="highlight">待机</span>
                <br><br>
                > 开普勒轨道: 运行中<br>
                > 粒子总数: <span id="particle-count-display">120万+</span><br>
                > 背景环境: 行星已加载
            </div>
        </div>
    </div>

    <div id="controls">
        <button onclick="toggleFullScreen()">全屏沉浸体验</button>
    </div>

    <!-- 3D场景容器 -->
    <div id="canvas-container"></div>

    <!-- 土星顶点着色器：处理粒子位置、大小和动态效果 -->
    <script type="x-shader/x-vertex" id="vertexshader">
        // 输入属性
        attribute float size;          // 粒子基础大小
        attribute vec3 customColor;   // 粒子颜色
        attribute float opacityAttr;  // 粒子透明度
        attribute float orbitSpeed;   // 轨道速度（用于光环旋转）
        attribute float isRing;       // 是否为光环粒子（0=行星本体，1=光环）
        attribute float aRandomId;   // 随机ID（用于LOD优化）
        
        // 传递给片元着色器的变量
        varying vec3 vColor;          // 粒子颜色
        varying float vDist;          // 距离摄像机的距离
        varying float vOpacity;       // 粒子透明度
        varying float vScaleFactor;    // 缩放因子
        varying float vIsRing;        // 是否为光环粒子
        
        // Uniform变量（由JavaScript控制）
        uniform float uTime;          // 时间值
        uniform float uScale;         // 缩放值
        uniform float uRotationX;     // X轴旋转（俯仰角）
        uniform float uRotationY;     // Y轴旋转（水平旋转）
        
        // 2D旋转矩阵函数
        mat2 rotate2d(float _angle){
            return mat2(cos(_angle),-sin(_angle),
                        sin(_angle),cos(_angle));
        }

        // 哈希函数：生成伪随机数
        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
            // 根据缩放级别做 LOD (细节层次) 剔除，离得远就不渲染那么多点
            float normScaleLOD = clamp((uScale - 0.15) / 2.35, 0.0, 1.0);
            float visibilityThreshold = 0.9 + pow(normScaleLOD, 1.2) * 0.1; 

            // 具体来讲，如果随机ID大于阈值，直接把点扔出屏幕，省显卡资源
            if (aRandomId > visibilityThreshold) {
                gl_Position = vec4(0.0);
                gl_PointSize = 0.0;
                return;
            }

            vec3 pos = position;

            // 行星本体和光环分别旋转，增加动态感
            if (isRing > 0.5) {
                // 光环旋转
                float angleOffset = uTime * orbitSpeed * 0.2;
                vec2 rotatedXZ = rotate2d(angleOffset) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            } else {
                // 行星本体旋转
                float bodyAngle = uTime * 0.03;
                vec2 rotatedXZ = rotate2d(bodyAngle) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            }

            // Y轴旋转：控制星球表观旋转（由手掌X轴位置控制）
            float cy = cos(uRotationY);
            float sy = sin(uRotationY);
            float rx = pos.x * cy - pos.z * sy;
            float rz2 = pos.x * sy + pos.z * cy;
            pos.x = rx;
            pos.z = rz2;
            
            // X轴旋转：控制俯仰角（由手掌Y轴位置控制）
            float cx = cos(uRotationX);
            float sx = sin(uRotationX);
            float ry = pos.y * cx - pos.z * sx;
            float rz = pos.y * sx + pos.z * cx;
            pos.y = ry;
            pos.z = rz;

            // 转换到相机空间
            vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
            float dist = -mvPosition.z;
            vDist = dist;

            // 混沌噪点效果：近距离观察时让粒子位置产生抖动，模拟气体湍流
            float chaosThreshold = 25.0; 
            if (dist < chaosThreshold && dist > 0.1) {
                float chaosIntensity = 1.0 - (dist / chaosThreshold);
                chaosIntensity = pow(chaosIntensity, 3.0);

                float highFreqTime = uTime * 40.0; 
                float noiseX = sin(highFreqTime + pos.x * 10.0) * hash(pos.y);
                float noiseY = cos(highFreqTime + pos.y * 10.0) * hash(pos.x);
                float noiseZ = sin(highFreqTime * 0.5) * hash(pos.z);
                
                vec3 noiseVec = vec3(noiseX, noiseY, noiseZ) * chaosIntensity * 3.0;
                mvPosition.xyz += noiseVec;
            }
            
            gl_Position = projectionMatrix * mvPosition;
            
            // 根据距离计算粒子大小（透视投影效果）
            float pointSize = size * (350.0 / dist); 
            pointSize *= 0.55; 

            // 近距离观察行星本体时，稍微把粒子变小一点，看起来更细腻
            if (isRing < 0.5 && dist < 50.0) {
                 pointSize *= 0.8; 
            }

            gl_PointSize = clamp(pointSize, 0.0, 300.0);

            // 传递数据给片元着色器
            vColor = customColor;
            vOpacity = opacityAttr;
            vScaleFactor = uScale;
            vIsRing = isRing;
        }
    </script>

    <!-- 土星片元着色器：处理颜色、光晕和材质效果 -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        // 从顶点着色器接收的变量
        varying vec3 vColor;          // 粒子颜色
        varying float vDist;          // 距离摄像机的距离
        varying float vOpacity;       // 粒子透明度
        varying float vScaleFactor;   // 缩放因子
        varying float vIsRing;        // 是否为光环粒子
        
        void main() {
            // 将方形粒子转换为圆形
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            
            // 边缘羽化，做成光球的效果
            float glow = smoothstep(1.0, 0.4, r); 
            
            // 根据缩放比例计算过渡值
            float t = clamp((vScaleFactor - 0.15) / 2.35, 0.0, 1.0);

            // 颜色混合：放大时偏向原色，缩小时偏向深金色
            vec3 deepGold = vec3(0.35, 0.22, 0.05); 
            float colorMix = smoothstep(0.1, 0.9, t);
            vec3 baseColor = mix(deepGold, vColor, colorMix);

            // 根据缩放调整亮度
            float brightness = 0.2 + 1.0 * t; 

            // 密度透明度调整：缩放时增加粒子密度感
            float densityAlpha = 0.25 + 0.45 * smoothstep(0.0, 0.5, t);

            vec3 finalColor = baseColor * brightness;
            
            // 近距离纹理增强
            if (vDist < 40.0) {
                float closeMix = 1.0 - (vDist / 40.0);
                
                if (vIsRing < 0.5) {
                    // 行星本体：增加对比度和深色纹理
                    vec3 deepTexture = pow(vColor, vec3(1.4)) * 1.5; 
                    finalColor = mix(finalColor, deepTexture, closeMix * 0.8);
                } else {
                    // 光环：增加尘埃感
                    finalColor += vec3(0.15, 0.12, 0.1) * closeMix;
                }
            }

            // 防止近裁切面太生硬，添加淡出效果
            float depthAlpha = 1.0;
            if (vDist < 10.0) depthAlpha = smoothstep(0.0, 10.0, vDist);

            // 计算最终透明度
            float alpha = glow * vOpacity * densityAlpha * depthAlpha;
            
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <!-- 背景星空顶点着色器 -->
    <script type="x-shader/x-vertex" id="starVertexShader">
        attribute float size;        // 星星大小
        attribute vec3 customColor;   // 星星颜色
        varying vec3 vColor;          // 传递给片元着色器的颜色
        uniform float uTime;          // 时间值

        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float dist = -mvPosition.z;
            // 星星不需要太大，这里限制一下大小
            gl_PointSize = size * (1000.0 / dist); 
            gl_PointSize = clamp(gl_PointSize, 1.0, 8.0);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- 背景星空片元着色器 -->
    <script type="x-shader/x-fragment" id="starFragmentShader">
        varying vec3 vColor;          // 从顶点着色器接收的颜色
        uniform float uTime;          // 时间值
        
        // 随机函数：生成伪随机数
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        
        void main() {
            // 将方形点转换为圆形
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            
            // 模拟星星闪烁效果
            float noise = random(gl_FragCoord.xy);
            float twinkle = 0.7 + 0.3 * sin(uTime * 2.0 + noise * 10.0);
            
            // 创建星星光晕效果
            float glow = 1.0 - r;
            glow = pow(glow, 1.5);
            
            gl_FragColor = vec4(vColor * twinkle, glow * 0.8);
        }
    </script>

    <!-- 行星顶点着色器 -->
    <script type="x-shader/x-vertex" id="planetVertexShader">
        // 传递给片元着色器的变量
        varying vec2 vUv;              // UV纹理坐标，用于纹理采样
        varying vec3 vNormal;           // 顶点法线，用于光照计算
        varying vec3 vViewPosition;     // 顶点在视图空间中的位置，用于视线方向计算
        
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            // 取负值是因为相机看向-Z方向
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <!-- 行星片元着色器：程序化生成纹理 -->
    <script type="x-shader/x-fragment" id="planetFragmentShader">
        // Uniform变量（由JavaScript控制）
        uniform vec3 color1;           // 主色调1（如深蓝色）
        uniform vec3 color2;           // 主色调2（如白色）
        uniform float noiseScale;      // 噪声缩放因子，控制纹理细节密度
        uniform vec3 lightDir;         // 光照方向向量
        uniform float atmosphere;      // 大气层强度系数
        
        // 从顶点着色器接收的变量
        varying vec2 vUv;              // UV纹理坐标
        varying vec3 vNormal;           // 顶点法线
        varying vec3 vViewPosition;     // 视图空间位置

        // 基础噪声函数
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        float noise(vec2 st) {
            vec2 i = floor(st);        // 整数部分（网格坐标）
            vec2 f = fract(st);        // 小数部分（网格内位置）
            
            // 获取四个角点的随机值
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            
            // 平滑插值函数（smoothstep）
            vec2 u = f * f * (3.0 - 2.0 * f);
            
            // 双线性插值
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        
        // 分形布朗运动(FBM)：通过多层噪声叠加创建自然的纹理效果
        // 用于生成地形、云层、岩石等自然纹理
        float fbm(vec2 st) {
            float value = 0.0;         // 累积噪声值
            float amplitude = 0.5;     // 初始振幅
            
            // 叠加5层不同频率的噪声
            for (int i = 0; i < 5; i++) {
                value += amplitude * noise(st);  // 添加当前层噪声
                st *= 2.0;                      // 增加频率（细节更丰富）
                amplitude *= 0.5;               // 减少振幅（影响更细微）
            }
            return value;
        }

        void main() {
            // 根据噪声生成地表颜色
            float n = fbm(vUv * noiseScale);
            vec3 albedo = mix(color1, color2, n);
            
            // 2. 光照计算：Lambert漫反射模型
            vec3 normal = normalize(vNormal);
            vec3 light = normalize(lightDir);
            float diff = max(dot(normal, light), 0.05); // 添加环境光
            
            // 3. 菲涅尔效应：模拟大气层边缘发光
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
            
            // 4. 最终颜色合成：漫反射 + 大气层发光
            vec3 finalColor = albedo * diff + atmosphere * vec3(0.5, 0.6, 1.0) * fresnel;
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        let scene, camera, renderer, particles, stars, nebula;
        let planetGroup;
        let uniforms, starUniforms;
        
        // 动画控制变量：目标值 vs 当前值，用于平滑过渡
        let targetScale = 1.0, targetRotX = 0.4, targetRotY = 0.0;
        let currentScale = 1.0, currentRotX = 0.4, currentRotY = 0.0;
        
        let isHandDetected = false;
        
        // ==================== 手势平滑滤波器类 ====================
        // 用于平滑手势识别结果，减少抖动和突变
        class GestureSmoother {
            // 增加smoothFactor值，减少historySize以提高响应速度
            constructor(smoothFactor = 0.6, historySize = 3) {
                this.smoothFactor = smoothFactor;
                this.historySize = historySize;
                
                this.previousLandmarks = null;
                this.previousGestureState = null;
                this.stateHistory = [];
                this.zoomHistory = [];
                this.rotationXHistory = [];
                this.rotationYHistory = [];
            }
            
            // 平滑处理手部关键点坐标
            smoothLandmarks(currentLandmarks) {
                if (!currentLandmarks) return null;
                
                if (!this.previousLandmarks) {
                    this.previousLandmarks = currentLandmarks.map(lm => ({...lm}));
                    return currentLandmarks;
                }
                
                // 对每个关键点进行加权平均
                const smoothed = currentLandmarks.map((curr, i) => {
                    const prev = this.previousLandmarks[i];
                    return {
                        x: prev.x * (1 - this.smoothFactor) + curr.x * this.smoothFactor,
                        y: prev.y * (1 - this.smoothFactor) + curr.y * this.smoothFactor,
                        z: prev.z * (1 - this.smoothFactor) + curr.z * this.smoothFactor
                    };
                });
                
                this.previousLandmarks = smoothed;
                return smoothed;
            }
            
            // 平滑处理手势参数（缩放、旋转）
            smoothGestureParams(currentGestureInfo) {
                if (!currentGestureInfo) return currentGestureInfo;
                
                // 维护固定长度的历史记录
                this.zoomHistory.push(currentGestureInfo.zoom);
                if (this.zoomHistory.length > this.historySize) this.zoomHistory.shift();
                
                // 计算加权平均值
                const weightedZoom = this.calculateWeightedAverage(this.zoomHistory);
                
                this.rotationXHistory.push(currentGestureInfo.rotationX);
                if (this.rotationXHistory.length > this.historySize) this.rotationXHistory.shift();
                
                const weightedRotX = this.calculateWeightedAverage(this.rotationXHistory);
                
                // 处理Y轴旋转参数
                this.rotationYHistory.push(currentGestureInfo.rotationY);
                if (this.rotationYHistory.length > this.historySize) this.rotationYHistory.shift();
                
                const weightedRotY = this.calculateWeightedAverage(this.rotationYHistory);
                
                return {
                    zoom: weightedZoom,
                    rotationX: weightedRotX,
                    rotationY: weightedRotY
                };
            }
            
            // 计算指数加权平均值，使最近的数据权重更高
            calculateWeightedAverage(values) {
                if (values.length === 0) return 0;
                if (values.length === 1) return values[0];
                
                let totalWeight = 0;
                let weightedSum = 0;
                
                // 预先计算权重总和
                const maxWeight = values.length;
                totalWeight = maxWeight * (maxWeight + 1) / 2;
                
                // 越新的值权重越大
                for (let i = 0; i < values.length; i++) {
                    weightedSum += values[i] * (i + 1);
                }
                
                return weightedSum / totalWeight;
            }
            
            // 重置所有历史记录
            reset() {
                this.previousLandmarks = null;
                this.stateHistory = [];
                this.zoomHistory = [];
                this.rotationXHistory = [];
                this.rotationYHistory = [];
            }
        }
        
        const gestureSmoother = new GestureSmoother(0.6, 5);
        
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status-indicator');
        const loadingElement = document.getElementById('loading');

        // 初始化Three.js场景和所有3D元素
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            // 远处的雾，增加深邃感
            scene.fog = new THREE.FogExp2(0x020202, 0.00015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 100;
            camera.lookAt(0, 0, 0);

            // 初始化各个3D元素
            initSaturn();      // 土星粒子系统
            initStarfield();   // 背景星空
            initPlanets();     // 背景行星

            // 创建WebGL渲染器，配置性能优化选项
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,                    // 开启抗锯齿
                alpha: true,                         // 支持透明背景
                powerPreference: "high-performance", // 告诉浏览器尽量用独显
                preserveDrawingBuffer: false         // 关闭缓冲区保存，提高性能，但会禁用截图功能
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比，防止高分屏卡顿
            renderer.setClearColor(0x000000, 0); 
            container.appendChild(renderer.domElement);

            // 窗口大小变化时更新相机和渲染器
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 启动动画循环
            animate();
        }

        // 格式化大数字为易读格式（如：120000 -> 12万）
        function formatNumber(num) {
            if (num >= 10000) {
                return (num / 10000).toFixed(1).replace(/\.0$/, '') + '万';
            }
            return num.toString();
        }

        // 初始化土星粒子系统
        function initSaturn() {
            const particleCount = 800000; // 粒子总数
            
            // 更新UI显示的粒子总数
            const particleCountDisplay = document.getElementById('particle-count-display');
            if (particleCountDisplay) {
                particleCountDisplay.textContent = formatNumber(particleCount) + '+';
            }
            
            const geometry = new THREE.BufferGeometry();
            
            // 分配粒子属性数组内存
            const positions = new Float32Array(particleCount * 3);   // 位置坐标(x,y,z)
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const opacities = new Float32Array(particleCount);
            const orbitSpeeds = new Float32Array(particleCount);
            const isRings = new Float32Array(particleCount);
            const randomIds = new Float32Array(particleCount);

            // 土星本体颜色调色板
            const bodyColors = [
                new THREE.Color('#E3DAC5'), 
                new THREE.Color('#C9A070'), 
                new THREE.Color('#E3DAC5'), 
                new THREE.Color('#B08D55')  
            ];
            
            // 土星环各层颜色（基于卡西尼号探测器数据）
            const colorRingC = new THREE.Color('#2A2520');
            const colorRingB_Inner = new THREE.Color('#CDBFA0');
            const colorRingB_Outer = new THREE.Color('#DCCBBA');
            const colorCassini = new THREE.Color('#050505');
            const colorRingA = new THREE.Color('#989085');
            const colorRingF = new THREE.Color('#AFAFA0');

            const R_PLANET = 18; // 行星基础半径

            // 生成所有粒子属性
            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b, size, opacity, speed, isRingVal;
                randomIds[i] = Math.random();

                // 前25%的粒子用于土星本体
                if (i < particleCount * 0.25) {
                    isRingVal = 0.0;
                    speed = 0.0;
                    
                    // 球面坐标系生成粒子位置
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const rad = R_PLANET;
                    
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    let rawY = rad * Math.cos(phi);
                    z = rad * Math.sin(phi) * Math.sin(theta);
                    
                    // 土星是扁的，压扁一点 Y 轴
                    y = rawY * 0.9;
                    
                    // 生成土星条纹图案
                    let lat = (rawY / rad + 1.0) * 0.5; 
                    let bandNoise = Math.cos(lat * 40.0) * 0.8 + Math.cos(lat * 15.0) * 0.4;
                    let colIndex = Math.floor(lat * 4 + bandNoise) % 4;
                    if (colIndex < 0) colIndex = 0;
                    let baseCol = bodyColors[colIndex];
                    
                    r = baseCol.r; g = baseCol.g; b = baseCol.b;
                    size = 1.0 + Math.random() * 0.8; 
                    opacity = 0.8; 
                } else {
                    // 剩余75%的粒子用于土星环
                    isRingVal = 1.0;
                    let zoneRand = Math.random();
                    let ringRadius;
                    let ringCol;
                    
                    // 根据概率分布生成不同的环带 (C环, B环, 卡西尼缝, A环, F环)
                    if (zoneRand < 0.15) { 
                        // C环：较暗，较内层
                        ringRadius = R_PLANET * (1.235 + Math.random() * (1.525 - 1.235));
                        ringCol = colorRingC;
                        size = 0.5; opacity = 0.3; 
                    } else if (zoneRand < 0.65) { 
                        // B环：最亮，最宽
                        let t = Math.random();
                        ringRadius = R_PLANET * (1.525 + t * (1.95 - 1.525));
                        ringCol = colorRingB_Inner.clone().lerp(colorRingB_Outer, t);
                        size = 0.8 + Math.random() * 0.6; opacity = 0.85; 
                        // B环某些区域密度更高
                        if (Math.sin(ringRadius * 2.0) > 0.8) opacity *= 1.2;
                    } else if (zoneRand < 0.69) { 
                        // 卡西尼缝: 几乎是空的，粒子很少且暗
                        ringRadius = R_PLANET * (1.95 + Math.random() * (2.025 - 1.95));
                        ringCol = colorCassini;
                        size = 0.3; opacity = 0.1; 
                    } else if (zoneRand < 0.99) { 
                        // A环
                        ringRadius = R_PLANET * (2.025 + Math.random() * (2.27 - 2.025));
                        ringCol = colorRingA;
                        size = 0.7; opacity = 0.6;
                        // 恩克环缝
                        if (ringRadius > R_PLANET * 2.2 && ringRadius < R_PLANET * 2.21) opacity = 0.1;
                    } else { 
                        // F环：最外层，很细
                        ringRadius = R_PLANET * (2.32 + Math.random() * 0.02);
                        ringCol = colorRingF;
                        size = 1.0; opacity = 0.7;
                    }
                    
                    // 环形分布
                    const theta = Math.random() * Math.PI * 2;
                    x = ringRadius * Math.cos(theta);
                    z = ringRadius * Math.sin(theta);
                    
                    // 环也是有厚度的，稍微随机一点 Y
                    let thickness = 0.15;
                    if (ringRadius > R_PLANET * 2.3) thickness = 0.4; 
                    y = (Math.random() - 0.5) * thickness;
                    
                    r = ringCol.r; g = ringCol.g; b = ringCol.b;
                    
                    // 开普勒第三定律：越外层转得越慢
                    speed = 8.0 / Math.sqrt(ringRadius);
                }
                
                positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                colors[i*3] = r; colors[i*3+1] = g; colors[i*3+2] = b;
                sizes[i] = size; opacities[i] = opacity;
                orbitSpeeds[i] = speed; isRings[i] = isRingVal;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('opacityAttr', new THREE.BufferAttribute(opacities, 1));
            geometry.setAttribute('orbitSpeed', new THREE.BufferAttribute(orbitSpeeds, 1));
            geometry.setAttribute('isRing', new THREE.BufferAttribute(isRings, 1));
            geometry.setAttribute('aRandomId', new THREE.BufferAttribute(randomIds, 1));

            uniforms = {
                uTime: { value: 0 },
                uScale: { value: 1.0 },
                uRotationX: { value: 0.4 },
                uRotationY: { value: 0.0 }
            };

            // 创建着色器材质
            const material = new THREE.ShaderMaterial({
                depthWrite: false, // 不写入深度缓冲区，防止粒子互相遮挡产生黑边
                blending: THREE.AdditiveBlending, // 叠加混合模式，让光环看起来更亮
                vertexColors: true,
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            particles.rotation.z = 26.73 * (Math.PI / 180); // 土星真实的轴倾角为 26.73°
            scene.add(particles);
        }

        // 初始化星空背景（星星和星云）
        function initStarfield() {
            const starCount = 50000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(starCount * 3);
            const cols = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            // 星星颜色类型
            const starColors = [
                new THREE.Color('#9bb0ff'), new THREE.Color('#ffffff'), 
                new THREE.Color('#ffcc6f'), new THREE.Color('#ff7b7b')
            ];

            for(let i=0; i<starCount; i++) {
                // 球面坐标系生成星星位置，距离400-3400单位
                const r = 400 + Math.random() * 3000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // 转换为笛卡尔坐标
                pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.cos(phi);
                pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                
                const colorType = Math.random();
                let c;
                if(colorType > 0.9) c = starColors[0]; else if(colorType > 0.6) c = starColors[1];
                else if(colorType > 0.3) c = starColors[2]; else c = starColors[3];
                
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                sizes[i] = 1.0 + Math.random() * 3.0;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('customColor', new THREE.BufferAttribute(cols, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            starUniforms = { uTime: { value: 0 } };
            const mat = new THREE.ShaderMaterial({
                uniforms: starUniforms,
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: document.getElementById('starFragmentShader').textContent,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            stars = new THREE.Points(geo, mat);
            scene.add(stars);

            // 创建星云效果（使用大粒子模拟）
            const nebulaCount = 100;
            const nebGeo = new THREE.BufferGeometry();
            const nebPos = new Float32Array(nebulaCount * 3);
            const nebCols = new Float32Array(nebulaCount * 3);
            const nebSizes = new Float32Array(nebulaCount);
            for(let i=0; i<nebulaCount; i++) {
                // 星云距离更远，800-2800单位
                const r = 800 + Math.random() * 2000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.PI / 2 + (Math.random() - 0.5) * 1.5; // 主要集中在赤道面上
                nebPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                nebPos[i*3+1] = r * Math.cos(phi);
                nebPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                
                // 星云颜色：蓝紫色系，低亮度
                const nc = new THREE.Color().setHSL(0.6 + Math.random()*0.2, 0.8, 0.05);
                nebCols[i*3] = nc.r; nebCols[i*3+1] = nc.g; nebCols[i*3+2] = nc.b;
                nebSizes[i] = 400.0 + Math.random() * 600.0;
            }
            nebGeo.setAttribute('position', new THREE.BufferAttribute(nebPos, 3));
            nebGeo.setAttribute('customColor', new THREE.BufferAttribute(nebCols, 3));
            nebGeo.setAttribute('size', new THREE.BufferAttribute(nebSizes, 1));
            
            // 星云着色器材质
            const nebShaderMat = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: document.getElementById('starVertexShader').textContent,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        float r = dot(cxy, cxy);
                        if(r > 1.0) discard;
                        float glow = pow(1.0 - r, 2.0);
                        gl_FragColor = vec4(vColor, glow * 0.1); 
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            nebula = new THREE.Points(nebGeo, nebShaderMat);
            scene.add(nebula);
        }

        // 初始化背景行星
        function initPlanets() {
            planetGroup = new THREE.Group();
            scene.add(planetGroup);

            const vShader = document.getElementById('planetVertexShader').textContent;
            const fShader = document.getElementById('planetFragmentShader').textContent;

            // 创建火星：红色行星，表面噪点多
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#b33a00'), new THREE.Color('#d16830'), 8.0, 
                { x: -300, y: 120, z: -450 }, 10, 0.3 
            );

            // 创建地球：蓝白相间
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#001e4d'), new THREE.Color('#ffffff'), 5.0, 
                { x: 380, y: -100, z: -600 }, 14, 0.6 
            );

            // 创建水星：灰白色，体积小
            createPlanet(planetGroup, vShader, fShader, 
                new THREE.Color('#666666'), new THREE.Color('#aaaaaa'), 15.0, 
                { x: -180, y: -220, z: -350 }, 6, 0.1 
            );
        }

        function createPlanet(group, vShader, fShader, c1, c2, nScale, pos, radius, atmo) {
            const geo = new THREE.SphereGeometry(radius, 48, 48);
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    color1: { value: c1 },
                    color2: { value: c2 },
                    noiseScale: { value: nScale },
                    lightDir: { value: new THREE.Vector3(1, 0.5, 1) },
                    atmosphere: { value: atmo }
                },
                vertexShader: vShader,
                fragmentShader: fShader
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            group.add(mesh);
        }

        // 时钟对象和自动巡航计时器
        const clock = new THREE.Clock();
        let autoIdleTime = 0;

        // 动画循环函数
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            uniforms.uTime.value = elapsedTime;
            if(starUniforms) starUniforms.uTime.value = elapsedTime;

            // 缓慢旋转背景星空
            if(stars) stars.rotation.y = elapsedTime * 0.005;
            if(nebula) nebula.rotation.y = elapsedTime * 0.003;
            
            // 行星自转
            if(planetGroup) {
                planetGroup.children.forEach((planet, idx) => {
                    planet.rotation.y = elapsedTime * (0.05 + idx * 0.02);
                });
                // 整个行星组稍微移动一点视差
                planetGroup.rotation.y = Math.sin(elapsedTime * 0.05) * 0.02;
            }
            
            // 平滑插值(Lerp)，使动作更顺滑
            let lerpFactor = 0.05;

            // 如果没检测到手，就开启自动巡航演示模式
            // 自动巡航模式下，行星大小和俯仰角缓慢周期性变化
            if (!isHandDetected) {
                lerpFactor = 0.01;
                // 自动巡航模式下，行星大小和俯仰角缓慢周期性变化
                autoIdleTime += 0.005;
                // autoIdleTime 为 20π 时，两个变量刚好完成了整数个周期变化
                // 为了防止溢出问题，每过 20π 就重置为0
                if(autoIdleTime > 20 * Math.PI) autoIdleTime = 0;

                targetScale = 1.0 + Math.sin(autoIdleTime) * 0.1;
                targetRotX = 0.4 + Math.sin(autoIdleTime * 0.3) * 0.15;
                statusElement.innerHTML = "系统状态: 自动巡航<br>输入信号: 等待中...";
                statusElement.style.color = "#666";
            } else {
                lerpFactor = 0.15;
                statusElement.innerHTML = "系统状态: 手动接管<br>输入信号: <span class='highlight'>已锁定</span>";
                statusElement.style.color = "#c5a059";
            }
            
            // 平滑插值更新当前值
            currentScale += (targetScale - currentScale) * lerpFactor;
            currentRotX += (targetRotX - currentRotX) * lerpFactor;
            currentRotY += (targetRotY - currentRotY) * lerpFactor;

            uniforms.uScale.value = currentScale;
            uniforms.uRotationX.value = currentRotX;
            uniforms.uRotationY.value = currentRotY;

            // 渲染场景
            renderer.render(scene, camera);
        }

        // 手部关键点显示相关变量
        let handLandmarksCanvas;
        let handLandmarksCtx;
        
        // 初始化手势追踪
        const hands = new Hands({locateFile: (file) => {
            return `./libs/${file}`;
        }});
        
        // 初始化手部关键点画布
        function initHandLandmarksCanvas() {
            handLandmarksCanvas = document.getElementById('hand-landmarks-canvas');
            handLandmarksCtx = handLandmarksCanvas.getContext('2d');
            
            // 初始设置默认尺寸，将在摄像头启动后更新为实际尺寸
            handLandmarksCanvas.width = 160;
            handLandmarksCanvas.height = 120;
            
            // 清空画布
            clearHandLandmarksCanvas();
        }
        
        // 清空手部关键点画布
        function clearHandLandmarksCanvas() {
            if (handLandmarksCtx) {
                handLandmarksCtx.clearRect(0, 0, handLandmarksCanvas.width, handLandmarksCanvas.height);
            }
        }
        
        // 绘制手部关键点
        function drawHandLandmarks(landmarks) {
            if (!handLandmarksCtx || !landmarks) {
                clearHandLandmarksCanvas();
                return;
            }
            
            // 只在需要时清空画布
            if (this.lastLandmarks !== landmarks) {
                clearHandLandmarksCanvas();
                this.lastLandmarks = landmarks;
            } else {
                return; // 如果关键点没有变化，跳过重绘
            }
            
            clearHandLandmarksCanvas();
            // 使用浅拷贝而非直接引用赋值，避免对象突变问题
            this.lastLandmarks = landmarks.map(lm => ({...lm}));
            
            const canvasWidth = handLandmarksCanvas.width;
            const canvasHeight = handLandmarksCanvas.height;
            
            // 要显示的关键点索引 (0-8)
            const targetIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8];
            
            // 连接线顺序：8 7 6 5 0 1 2 3 4
            const connectionOrder = [8, 7, 6, 5, 0, 1, 2, 3, 4];
            
            // 存储点位置
            const points = [];
            
            // 绘制关键点
            for (let i = 0; i < targetIndices.length; i++) {
                const index = targetIndices[i];
                if (index < landmarks.length) {
                    const landmark = landmarks[index];
                    // 将关键点位置映射到画布，并左右翻转x坐标（否则显示的时候是左右颠倒的）
                    const x = canvasWidth - landmark.x * canvasWidth;
                    const y = landmark.y * canvasHeight;
                    points[index] = {x, y};
                    
                    // 设置点的颜色 (4和8是红色，其他是绿色)
                    handLandmarksCtx.fillStyle = (index === 4 || index === 8) ? '#ff0000' : '#00ff00';
                    
                    // 绘制点
                    handLandmarksCtx.beginPath();
                    handLandmarksCtx.arc(x, y, 3, 0, 2 * Math.PI);
                    handLandmarksCtx.fill();
                }
            }
            
            // 绘制连接线
            handLandmarksCtx.strokeStyle = '#ffffff';
            handLandmarksCtx.lineWidth = 1;
            handLandmarksCtx.beginPath();
            
            for (let i = 0; i < connectionOrder.length; i++) {
                const index = connectionOrder[i];
                const point = points[index];
                
                if (point) {
                    if (i === 0) {
                        // 移动到第一个点
                        handLandmarksCtx.moveTo(point.x, point.y);
                    } else {
                        // 连接到当前点
                        handLandmarksCtx.lineTo(point.x, point.y);
                    }
                }
            }
            
            handLandmarksCtx.stroke();
        }

        // 配置手势检测参数
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        let hand = null; // 全局手部关键点变量

        // 手势检测结果处理函数
        function onResults(results) {
            loadingElement.style.display = 'none';

            // 检测到手部
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                hand = results.multiHandLandmarks[0]; // 记录手部关键点
                
                // 使用手势平滑器平滑关键点
                const smoothedHand = gestureSmoother.smoothLandmarks(hand);
                
                // 用大拇指和食指的平面投影距离控制缩放
                const p1 = smoothedHand[4];
                const p2 = smoothedHand[8];
                const dist = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
                
                drawHandLandmarks(hand, dist);
                
                // 归一化距离并映射到缩放系数
                const normDist = Math.max(0, Math.min(1, (dist - 0.02) / 0.25));
                targetScale = 0.15 + normDist * 2.35; 

                // 用手掌在屏幕的 Y 轴位置控制俯仰角
                const y = smoothedHand[9].y;
                const normY = Math.max(0, Math.min(1, (y - 0.1) / 0.8));
                targetRotX = -0.6 + normY * 1.6;
                
                // 用手掌在屏幕的 X 轴位置控制星球表观旋转角
                const x = smoothedHand[9].x;
                const normX = Math.max(0, Math.min(1, (x - 0.1) / 0.7));
                targetRotY = -Math.PI/2 + normX * Math.PI; // 旋转范围为-90度到90度
                
                // 使用平滑器处理手势参数
                const smoothedParams = gestureSmoother.smoothGestureParams({
                    zoom: targetScale,
                    rotationX: targetRotX,
                    rotationY: targetRotY
                });
                
                targetScale = smoothedParams.zoom;
                targetRotX = smoothedParams.rotationX;
                targetRotY = smoothedParams.rotationY;

            } else {
                isHandDetected = false;
                gestureSmoother.reset();
                // 清空手部关键点显示
                clearHandLandmarksCanvas();
            }
        }

        // 摄像头分辨率
        const CAMERA_WIDTH = 640;
        const CAMERA_HEIGHT = 480;
        
        // 启动摄像头
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                // 将视频帧发送给MediaPipe进行手势识别
                await hands.send({image: videoElement});
            },
            width: CAMERA_WIDTH,
            height: CAMERA_HEIGHT
        });
        
        cameraUtils.start().catch(e => {
            console.error(e);
            loadingElement.innerText = "摄像头启动失败";
        });

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }

        // 初始化系统
        initThree();
        initHandLandmarksCanvas();

    </script>
</body>
</html>